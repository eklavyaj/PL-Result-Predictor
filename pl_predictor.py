# -*- coding: utf-8 -*-
"""PL_Predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12COsXdCSssxh258HDbRKg4z2IL9QZY5i
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd drive/My\ Drive/Premier-League-Result-Predictor

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score

from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier

from yellowbrick.classifier import ClassificationReport, ClassificationScoreVisualizer

fixtures = pd.read_csv('fixtures.csv')

#cleaning fixtures data

fixtures = fixtures[9663:923:-1].reset_index()
fixtures.drop(['index', 'Div', 'Date', 'Season'], inplace=True, axis=1)
fixtures.loc[:,'HTHG'] = fixtures['HTHG'].astype(int)
fixtures.loc[:,'HTAG'] = fixtures['HTAG'].astype(int)


seasons = np.arange(2018, 1995 , -1)
fixtures.loc[:,'Season'] = pd.Series(np.repeat(seasons , 380))

fixtures.loc[fixtures['HomeTeam'] == 'Middlesboro','HomeTeam'] = 'Middlesbrough'
fixtures.loc[fixtures['AwayTeam'] == 'Middlesboro', 'AwayTeam'] = 'Middlesbrough'

fixtures['HGD']=pd.Series((fixtures['HTHG']-fixtures['HTAG']))
fixtures['FGD']=pd.Series((fixtures['FTHG']-fixtures['FTAG']))

fixtures.head(10)
# len(fixtures)

hm1 = fixtures["FTR"][fixtures["HTR"]=="H"].value_counts()["H"]
hm4 = fixtures["FTR"][fixtures["HTR"]=="H"].value_counts()["D"]
hm7 = fixtures["FTR"][fixtures["HTR"]=="H"].value_counts()["A"]
hm2 = fixtures["FTR"][fixtures["HTR"]=="D"].value_counts()["H"]
hm5 = fixtures["FTR"][fixtures["HTR"]=="D"].value_counts()["D"]
hm8 = fixtures["FTR"][fixtures["HTR"]=="D"].value_counts()["A"]
hm3 = fixtures["FTR"][fixtures["HTR"]=="A"].value_counts()["H"]
hm6 = fixtures["FTR"][fixtures["HTR"]=="A"].value_counts()["D"]
hm9 = fixtures["FTR"][fixtures["HTR"]=="A"].value_counts()["A"]
arr = np.array([hm1, hm2, hm3, hm4, hm5, hm6, hm7, hm8, hm9])
arr = np.resize(arr , (3,3))
df = pd.DataFrame(arr, columns=('H', 'D', 'A'), index = ['H', 'D', 'A'])
sns.heatmap(df , cmap = "RdYlGn")
plt.show()

half = sns.catplot('Season', data=fixtures, kind='count', hue='HTR', order=range(2009,2019))
half.set_ylabels('Match Winner at Half time')
half.set_xticklabels(rotation=90);

full = sns.catplot('Season', data=fixtures, kind='count', hue='FTR', order=range(2009,2019))
full.set_ylabels('Match Winner at Full time')
full.set_xticklabels(rotation=90);

g = sns.FacetGrid(fixtures, col = "FTR")
g = (g.map(plt.hist , "HTR" , color = 'g')).set_xticklabels(["H", "A", "D"])
plt.show()

positions = pd.read_csv('positions.csv')

positions.loc[positions['team']=='West Ham', 'team']='West Ham United'
positions = positions[20:502].reset_index()
positions.drop(['season','name','index','gd','f','a'], axis=1, inplace=True)
seasons = np.arange(2018,1994,-1)
dup = np.repeat(seasons,20)
dup = np.append(dup,[1995,1995])
positions.loc[:,'Season']=pd.Series(dup)

positions.head()

temp = positions[:460]
fix_teams = np.array(sorted(list(set(fixtures['HomeTeam']))))
pos_teamsi = np.array(sorted(list(set(temp['team']))))

pos_teams = [vals.strip() for vals in pos_teamsi]

val = dict(zip(fix_teams, pos_teams))
val2 = dict(zip(pos_teamsi , pos_teams))

fixtures['HomeTeam'].replace(val, inplace=True)
fixtures['AwayTeam'].replace(val,inplace=True)
positions['team'].replace(val2,inplace=True)

#form 

seasons=sorted(list(set(positions['Season'])), reverse=True)
teams=list(set(positions['team']))
# teams

total = positions['points'].groupby(positions['Season']).max()
indices=total.index.values.tolist()
# indices

forms=[]

for team, season in zip(positions['team'],positions['Season']):
    if season>1994:
        totalpoints=0
        points=(np.sum(positions['points'].where((positions['team']==team) & (positions['Season']<=season) & (positions['Season']>(season-2)) )))
        totalpoints=np.sum(total.where((total.index.values<=season) & (total.index.values>(season-2))))
        form=(points/totalpoints)
        forms.append(form)
    else: 
        forms.append(0.0)
        
positions['form']=pd.Series(forms)


positions.head()

Teams = np.unique(fixtures['HomeTeam'])
Teams

Results = np.unique(fixtures['HTR'])
Results

df=fixtures.copy()

enc1 = LabelEncoder()

df['HomeTeam'] = enc1.fit_transform(df['HomeTeam'])
df['AwayTeam'] = enc1.transform(df['AwayTeam'])

AllTeams = dict(zip(Teams, enc1.transform(Teams)))
AllTeams_inverse = dict(zip(enc1.transform(Teams), Teams))

enc2 = LabelEncoder()

df['HTR'] = enc2.fit_transform(df['HTR'])
df['FTR'] = enc2.transform(df['FTR'])

AllResults = dict(zip(Results , enc2.transform(Results)))
AllResults_inverse = dict(zip(enc2.transform(Results), Results))


df.head(10)

AllResults_inverse

X_train, X_test ,y_train , y_test = train_test_split(df[['HomeTeam','AwayTeam','HTR']], df['FTR'], random_state = 0)

neigh = KNeighborsClassifier(n_neighbors=18)
pred = neigh.fit(X_train, y_train).predict(X_test)

score = accuracy_score(y_test, pred)
print('KNeighborsClassifier : {}'.format(score))

visual = ClassificationReport(neigh, classes=['Away','Draw','Home'])
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

decision = DecisionTreeClassifier(max_depth=4)
pred = decision.fit(X_train, y_train).predict(X_test)

score = accuracy_score(y_test, pred)
print('DecisionTreeClassifier : {}'.format(score))

visual = ClassificationReport(decision , classes=['Away','Draw','Home'])
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

naive = GaussianNB()
pred = naive.fit(X_train, y_train).predict(X_test)

score = accuracy_score(y_test, pred)
print('Naive-Bayes : {}'.format(score))

visual = ClassificationReport(naive , classes=['Away','Draw','Home'])
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

rfc = RandomForestClassifier(n_estimators=90, max_depth=4)
rfc.fit(X_train, y_train)
pred = rfc.predict(X_test)

score = accuracy_score(y_test, pred)
print('RandomForestClassifier : {}'.format(score))

visual = ClassificationReport(rfc , classes=['Away','Draw','Home'])
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

svc = SVC(kernel='linear', gamma='auto', random_state=0)
svc.fit(X_train, y_train)
pred = svc.predict(X_test)

score = accuracy_score(y_test, pred)
print('SVC - linear : {}'.format(score))

visual = ClassificationReport(svc)
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

rbf = SVC(kernel='rbf', gamma='auto')
pred = rbf.fit(X_train, y_train).predict(X_test)

score = accuracy_score(y_test, pred)
print('SVC-rbf : {}'.format(score))

visual = ClassificationReport(rbf , classes=['Away','Draw','Home'])
visual.fit(X_train, y_train)
visual.score(X_test, y_test)
graph = visual.poof()

import pickle

pickle.dump(rfc,open('final_predictions.pickle', 'wb'))

